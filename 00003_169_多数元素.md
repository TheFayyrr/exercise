# QUESTION
169. 多数元素
简单
相关标签
相关企业
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1：

输入：nums = [3,2,3]
输出：3
示例 2：

输入：nums = [2,2,1,1,1,2,2]
输出：2

# wrong answer
'''
cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        
        sort(nums.begin(),nums.end());
        int p=0;
        while (p<nums.size())
        {
            int count2 = count(nums.begin(), nums.end(), nums[p]);
            if(nums[p]>count2/2)
            {
                return nums[p];
            }
            p=count2;

        }
        
    }
};
'''

你的代码的思路是：

1. 对数组排序
2. 统计每个数字的出现次数
3. 找出出现次数 > ⌊n/2⌋ 的数

这是个可行的思路，但你代码中有几个**关键问题**导致它出错（甚至可能段错误或死循环）。

---

## ❌ 存在的问题

### ❗ 1. `count2 = count(...)` 是每次统计整个数组中 `nums[p]` 出现的次数，但你没有移动 `p` 正确地跳过重复项

比如：你想跳过所有相同的 `nums[p]`，但你错误地将 `p = count2`，这可能会跳错位置。

### ❗ 2. 判断条件 `if (nums[p] > count2 / 2)` 是错误的

应该是 **`if (count2 > nums.size() / 2)`**，你现在比较的是 `元素值` 与 `出现次数`，语义不对。

### ❗ 3. 函数没有 `return` 默认值（若逻辑没进入 `if` 就没有返回，会报错）

---

## ✅ 修正版：基于你原始思路进行更正

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // 排序后，相同元素会相邻
        int n = nums.size();
        int p = 0;

        while (p < n) {
            int current = nums[p];
            int count2 = count(nums.begin(), nums.end(), current);
            if (count2 > n / 2) {
                return current;
            }
            // 跳过当前元素的所有重复项
            while (p < n && nums[p] == current) {
                p++;
            }
        }

        return -1; // 实际不会到达这里，因为题目保证一定有多数元素
    }
};
```

---

## ✅ 更高效的方法：Boyer-Moore 投票算法（推荐）

时间复杂度 O(n)，空间 O(1)

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 0;
        int candidate = 0;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }

        return candidate;
    }
};
```

---

## ✅ 总结

| 方法          | 时间复杂度      | 空间复杂度 | 特点          |
| ----------- | ---------- | ----- | ----------- |
| 排序+遍历+count | O(n log n) | O(1)  | 简单但多次统计重复元素 |
| 投票算法        | O(n)       | O(1)  | 高效，最推荐      |

如果你希望用 `map` 或 `unordered_map` 来做统计，我也可以写出对应代码。是否想看？
# 题解
很好！我们来详细讲两个部分：

---

## ✅ 第一部分：Boyer-Moore 投票算法的原理

这个算法特别适合解决 “多数元素” 问题，时间复杂度是 **O(n)**，空间复杂度是 **O(1)**。

### **核心思想：**

* 如果一个数是**多数元素**，它的数量一定 > 所有其他元素数量的总和。
* 所以我们可以用一个变量 `count` 来做“投票”：

  * 当 `count == 0`，就更新候选人 `candidate = 当前数`
  * 如果当前数等于 `candidate`，`count++`
  * 如果当前数不等于 `candidate`，`count--`
* 遍历一轮下来，`candidate` 就是最终的多数元素。

### **例子：**

数组 `[2,2,1,1,1,2,2]`

```
candidate=2, count=1
→ 2 == 2 → count=2
→ 1 != 2 → count=1
→ 1 != 2 → count=0
→ count=0 → candidate=1
→ 1 == 1 → count=1
→ 2 != 1 → count=0
→ count=0 → candidate=2
→ 2 == 2 → count=1 → ✅ 最终结果：2
```

---

## ✅ 第二部分：哈希表解法（使用 `unordered_map`）

是的，这就是**哈希表**方法，我们用一个 map 来记录每个数出现了多少次。

### 🔑 `unordered_map` 是无序哈希表，查找/插入都是 O(1) 的平均复杂度。

### ✅ 示例代码：

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> freq;
        int n = nums.size();

        for (int num : nums) {
            freq[num]++; // 每出现一次就加一
            if (freq[num] > n / 2) {
                return num;
            }
        }

        return -1; // 理论上不会到这里
    }
};
```

### 📌 解释：

* `unordered_map<int, int> freq`：建一个哈希表，key 是数值，value 是出现次数。
* 每次 `freq[num]++` 都在统计当前数的出现次数。
* 如果发现某个数超过 `n / 2` 次，就直接返回。

---

## ✅ 总结对比：

| 方法          | 时间复杂度 | 空间复杂度 | 特点      |
| ----------- | ----- | ----- | ------- |
| Boyer-Moore | O(n)  | O(1)  | 最优，逻辑巧妙 |
| 哈希表（map）    | O(n)  | O(n)  | 简单易懂    |

---

如果你还不太会使用 `unordered_map` 或 `map` 的基本操作，我可以单独为你整理一份**C++ 哈希表入门讲解与例子**。需要吗？

