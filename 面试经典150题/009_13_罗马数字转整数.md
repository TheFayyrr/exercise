13. 罗马数字转整数
简单
相关标签
premium lock icon
相关企业
提示
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。


# error:
'''
class Solution {
public:
    int romanToInt(string s) {
    int result=0;
    int flag=0;
    for (int i=0;i<s.length();i++)
    {
    if (s[i]=='I')
    {
        result +=1;
        flag=1;
    }
    else if (s[i]=='V')
    {
        if(flag)
        {
        result =  result-1+4;
        }
        else result +=5;
    }
    else if (s[i]=='X')
    {
        if(flag)
        {
        result =  result-1+9;
        }
        else result +=10;
    }
    else if (s[i]=='L')
    {
        if(flag)
        {
        result =  result-1+40;
        }
        else result +=50;
    }
    else  if (s[i]=='C')
    {
        if(flag)
        {
        result =  result-1+90;
        }
        else result +=100;
    }
    else if (s[i]=='D')
    {
        if(flag)
        {
        result =  result-1+400;
        }
        else 
        result +=500;
    }
    else if (s[i]=='M')
    {
        if(flag)
        {
        result =  result-1+900;
        }
        else 
        result +=1000;

    }
    flag =0;
    }
    return result;
}
};
cpp
'''


# ChatGPT 
你这段代码思路其实不错！已经考虑到了罗马数字的减法规则（比如 IV、IX、XL、XC 等），逻辑大致是「先看字符，再判断前一个字符是不是小于当前字符」，用 `flag` 实现。但确实还有一些可以改进的地方，让逻辑更清晰、健壮、不容易出错。

---

## 🔍 **问题分析**

你说“**一看题就不会做，逻辑老有漏洞**”，其实这很常见，特别是涉及“前后字符关系”的问题。像这道题，其实可以归结为一个通用的逻辑模板，帮你理清：

> 如果当前字符的值 **大于前一个字符的值**，说明是一个“减法组合”，需要做 `result += 当前值 - 2 * 前一个值`
> 否则，就 `result += 当前值`

---

## ✅ **推荐写法（逻辑更清晰）**

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> roman = {
            {'I', 1}, {'V', 5}, {'X', 10},
            {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}
        };

        int result = 0;
        int prev = 0; // 前一个字符的值

        for (char c : s) {
            int curr = roman[c];
            // 如果当前比前一个大，说明是减法组合
            if (curr > prev) {
                result += curr - 2 * prev;
            } else {
                result += curr;
            }
            prev = curr;
        }
        return result;
    }
};
```

### 💡 核心逻辑是：

* 正常加每个字符的值；
* 如果发现当前值大于前一个值，比如 I -> V（1 < 5），就要用 `curr - 2 * prev` 来纠正之前多加的 `prev`（举例见下）。

---

## 🧠 举例解释

输入：`"IX"`

* `I` → 1，prev = 0 → 加 1（result = 1）
* `X` → 10，prev = 1 → 因为 10 > 1，所以执行：result += 10 - 2 \* 1 = 8 → result = 9 ✅

---

## 🧱 如果你经常觉得“一看题就没思路”，试试这样做：

1. **固定套路**：每种题型找“模板”（比如这题的「如果当前值 > 上一个值，则减两倍」）
2. **分类举例**：IV、IX、XL、XC、CD、CM 写出来，思考变化点
3. **自己画图/写流程图**：眼见为实，逻辑顺了就能写出代码
4. **多练 Easy 题打基础**，例如：

   * 两数之和（map思维）
   * 有效括号（栈）
   * 罗马数字转换（字符串遍历）

---

需要我帮你整理一个「常见 LeetCode 逻辑模板清单」或「字符串处理题型归纳」吗？这对打牢基本功特别有帮助。


太棒了！这是你打牢 LeetCode 基础、提升刷题效率的重要一步。以下我为你整理了一份「常见 LeetCode 逻辑模板清单」+「字符串处理题型归纳」，适合初中级选手逐步进阶：

---

# 🧩 常见 LeetCode 逻辑模板清单

| 类型         | 模板名称         | 解题技巧与套路                         |
| ---------- | ------------ | ------------------------------- |
| 🧠 模拟      | 遍历字符串/数组逐步处理 | if/else 处理细节，常见在罗马数字、字符串转整数等题中  |
| 🔁 双指针     | 快慢指针、滑动窗口    | 解决子串、子数组、去重等问题，空间 O(1) 很常用      |
| 🥇 哈希表     | 统计频率、记录索引    | 适用于“两数之和”“异位词判断”“最长不重复子串”等      |
| 📦 栈       | 括号匹配、表达式计算   | 处理“回溯型状态”或“先进后出”结构，如有效括号、逆波兰表达式 |
| 📈 前缀和     | 预处理累积量       | 快速计算区间和或差值，如和为 K 的子数组个数         |
| 🎲 排序 + 贪心 | 先排序再决策       | 常用于最小跳数、安排区间、会议室调度等             |
| 🧭 二分搜索    | 精确位置或满足条件的边界 | 典型如「搜索插入位置」「左侧界/右侧界」等           |
| 🌊 BFS/DFS | 图、树、组合搜索     | 用队列/递归/回溯来遍历结构或找路径              |
| 📉 动态规划    | 子问题递推        | 常见在子序列、背包、打家劫舍、斐波那契等问题          |

---

# 📚 字符串处理题型归纳

| 题型                  | 关键词                | 模板/思路                                         |
| ------------------- | ------------------ | --------------------------------------------- |
| ✅ 基础遍历              | 罗马数字、字符串转整数、回文判断   | 逐个字符分析，配合 flag/变量记录状态                         |
| 📏 滑动窗口             | 最长不含重复子串、最小覆盖子串    | 哈希 + 双指针，维护窗口状态                               |
| 🧮 字符频率统计           | 有效变位词、字母异位词分组      | `unordered_map<char, int>` 或 `array<int, 26>` |
| ✂️ 分割处理             | 字符串分词、IP地址划分、表达式拆分 | `substr()` + 递归/回溯 + DFS                      |
| 🔁 字符串变换            | ZigZag 转换、重复字符串匹配  | 根据索引或模拟结构变化构建新串                               |
| 🔄 双指针              | 回文串判断、反转字符串、左右移位   | 一头一尾夹逼或局部翻转                                   |
| 🧠 KMP / Rabin-Karp | 字符串匹配              | 用于实现 `strStr()`、子串搜索等高效查找                     |
| 🔍 正则匹配             | 正则表达式匹配、通配符匹配      | 动态规划 + 状态转移方程                                 |
| 🎯 拼接/构造            | 最长公共前缀、字符串相加、括号生成  | 按字符规则“构造”结果或枚举所有情况                            |

---

## 🔧 推荐练习题清单（可配合模板刷题）：

| 题名          | LeetCode 编号 | 涉及模板       |
| ----------- | ----------- | ---------- |
| 罗马数字转整数     | 13          | 模拟遍历       |
| 有效的括号       | 20          | 栈          |
| 最长不重复子串     | 3           | 哈希 + 双指针   |
| 字符串相加       | 415         | 逐位加法模拟     |
| 最小覆盖子串      | 76          | 滑动窗口       |
| 实现 strStr() | 28          | KMP（进阶）/暴力 |
| 字符串解码       | 394         | 栈处理嵌套结构    |
| 括号生成        | 22          | DFS 回溯     |
| 有效的字母异位词    | 242         | 哈希表计数      |

---

如果你希望我按“学习顺序”推荐每日训练路径、或者详细讲解每种模板的适用时机和编码套路，我可以为你定制一个「**LeetCode 刷题训练计划（字符串篇）**」。要不要安排一个？

